#!/usr/bin/env python

from __future__ import print_function

try:
    from cStringIO import StringIO
except ImportError:
    from io import StringIO
import argparse
import json
import subprocess
import textwrap
import os
import platform
import sys
import errno

def note(message):
    print("--- note: %s" % (message))
    sys.stdout.flush()

def error(message):
    print("--- %s: error: %s" % (os.path.basename(sys.argv[0]), message))
    sys.stdout.flush()
    raise SystemExit(1)

def symlink_force(target, link_name):
    if os.path.isdir(link_name):
        link_name = os.path.join(link_name, os.path.basename(target))
    try:
        os.symlink(target, link_name)
    except OSError as e:
        if e.errno == errno.EEXIST:
            os.remove(link_name)
            os.symlink(target, link_name)
        else:
            raise e

def mkdir_p(path):
    try:
        os.makedirs(path)
    except OSError as e:
        # Ignore EEXIST, which may occur during a race condition.
        if e.errno != errno.EEXIST:
            raise

def write_file_if_changed(path, data):
    try:
        with open(path) as f:
            old_data = f.read()
    except:
        old_data = None
    if old_data == data:
        return

    # Create directory if needed.
    mkdir_p(os.path.dirname(path))

    # Write the contents.
    with open(path, "w") as f:
        f.write(data)

def rmdir(dir):
    try:
        subprocess.check_call(["rm", "-rf", dir])
    except:
        note("couldn't remove %s" % dir)

###

g_project_root = os.path.dirname(os.path.dirname(os.path.abspath(__file__)))
g_build_path = os.path.join(g_project_root, ".build", "bootstrap")
g_source_root = os.path.join(g_project_root, "Sources")
g_shared_fwk = None
if platform.system() == 'Darwin':
    g_shared_fwk = subprocess.check_output(
        ["xcode-select", "-p"],
        universal_newlines=True).strip()

def dump_manifest():
    cmd = ["env", "SWIFTPM_BOOTSTRAP=1", "swift", "package", "dump-package"]
    note("Running: %s" % ' '.join(cmd))
    return subprocess.check_output(cmd, cwd=g_project_root)

def bootstrap(args):
    build_path = g_build_path
    note("Bootstrapping SwiftPM at %s" % build_path)
    mkdir_p(build_path)

    # CMake.
    cmake_cache_path = os.path.join(build_path, "CMakeCache.txt")
    if not os.path.isfile(cmake_cache_path):
        mkdir_p(build_path)
        cmd = ["cmake", "-G", "Ninja", "-DCMAKE_BUILD_TYPE:=Debug", ("-DLLBUILD_FRAMEWORK=%s/../SharedFrameworks" % g_shared_fwk), g_project_root]
        note("Running cmake for swiftpm bootstrap: %s" % ' '.join(cmd))
        subprocess.check_call(cmd, cwd=build_path)

    # Build.
    subprocess.check_call(["ninja"], cwd=g_build_path)

g_exclude_targets = [
    "PackageDescription4",
    "swiftpm-xctest-helper",
    "TestSupport",
    "TestSupportExecutable",
    "swift-package",
    "swift-run",
    "swift-build",
    "swift-test",
]

class Target(object):
    def __init__(self, target):
        # print(target["name"], target["dependencies"])
        self.name = target["name"]

        deps = []
        for dep in target["dependencies"]:
            deps.extend(dep["byName"])
        self.dependencies = deps

        self.sources = []
        module_root_dir = os.path.join(g_source_root, self.name)

        for (dirpath, dirnames, filenames) in os.walk(module_root_dir):
            for name in filenames:
                path = os.path.join(name)
                _, ext = os.path.splitext(name)
                if ext == '.swift':
                    self.sources.append(path)
        self.sources.sort()

    def __str__(self):
        return "Target<%s>: %s" % (self.name, self.dependencies)

def make_targets(manifest_json):
    targets = []
    for target in manifest_json["targets"]:
        if target["type"] != "regular" or target["name"] in g_exclude_targets:
            continue
        targets.append(Target(target))
    return targets

def add_preamble(output):
    preamble = textwrap.dedent("""\
        cmake_minimum_required(VERSION 3.14.20190603)
        
        project(SwiftPM LANGUAGES C Swift)
        
        # Place all modules into `swift` in the root of the build tree.
        set(CMAKE_Swift_MODULE_DIRECTORY ${CMAKE_BINARY_DIR}/swift)
        
        # enable shared libraries by default.
        option(BUILD_SHARED_LIBS "Build shared libraries by default" YES)
        
        # Get the SDK path for macOS.
        execute_process(
            COMMAND xcrun --sdk macosx --show-sdk-path
            OUTPUT_VARIABLE CMAKE_OSX_SYSROOT
            OUTPUT_STRIP_TRAILING_WHITESPACE)
        
        SET(CMAKE_Swift_FLAGS "${CMAKE_Swift_FLAGS} -sdk ${CMAKE_OSX_SYSROOT}")
        SET(CMAKE_Swift_FLAGS "${CMAKE_Swift_FLAGS} -swift-version 4.2")
        
        # For llbuild.
        option(LLBUILD_FRAMEWORK "Path to llbuild framework" "")
        option(LLBUILD_LIBRARY "Path to llbuild library" "")
        option(LLBUILD_SRC "Path to llbuild sources" "")
        
        if(LLBUILD_FRAMEWORK)
            message("==== Using llbuild framework at ${LLBUILD_FRAMEWORK}")
            SET(CMAKE_Swift_FLAGS "${CMAKE_Swift_FLAGS} -F${LLBUILD_FRAMEWORK}")
            SET(CMAKE_Swift_FLAGS "${CMAKE_Swift_FLAGS} -Xlinker -rpath -Xlinker ${LLBUILD_FRAMEWORK}")
        elseif(LLBUILD_BUILD_DIR)
            if(NOT LLBUILD_SRC)
                message(FATAL_ERROR "Need LLBUILD_SRC when using LLBUILD_LIBRARY")
            endif()
            message("==== Using llbuild build dir at ${LLBUILD_BUILD_DIR}")
            message("==== Using llbuild src at ${LLBUILD_SRC}")
            SET(CMAKE_Swift_FLAGS "${CMAKE_Swift_FLAGS} -I${LLBUILD_BUILD_DIR}/products/llbuildSwift")
            SET(CMAKE_Swift_FLAGS "${CMAKE_Swift_FLAGS} -I${LLBUILD_SRC}/products/libllbuild/include")
            SET(CMAKE_Swift_FLAGS "${CMAKE_Swift_FLAGS} -L${LLBUILD_BUILD_DIR}/lib")
            SET(CMAKE_Swift_FLAGS "${CMAKE_Swift_FLAGS} -Xlinker -rpath -Xlinker ${LLBUILD_BUILD_DIR}/lib")
        else()
            message(FATAL_ERROR "Need LLBUILD_FRAMEWORK or LLBUILD_SRC + LLBUILD_LIBRARY")
        endif()
        
        SET(CMAKE_Swift_FLAGS "${CMAKE_Swift_FLAGS} -Xlinker -rpath -Xlinker ${CMAKE_BINARY_DIR}")
        include_directories(${CMAKE_SOURCE_DIR}/Sources/clibc/include)""")

    print(preamble, file=output)

def add_library_targets(targets, output):
    for target in targets:
        # Hack.
        if target.name == "clibc":
            print("add_library(clibc STATIC Sources/clibc/libc.c)", file=output)
            continue

        deps = ' '.join(target.dependencies)

        srcs = ""
        for src in target.sources:
            srcs = srcs + "Sources/%s/%s\n" % (target.name, src)

        decl = textwrap.dedent("""\
            # ==================== {target} ==================== #
            file(GLOB {target}_SRC Sources/{target}/*.swift)
            add_library({target}""".format(target=target.name, srcs=srcs, deps=deps))
        print(decl, file=output)

        for src in target.sources:
            print("Sources/%s/%s" % (target.name, src), file=output)
        print(")", file=output)

        decl = textwrap.dedent("""\
            target_link_libraries({target}
                {deps})
            set_target_properties({target} PROPERTIES
                INTERFACE_INCLUDE_DIRECTORIES ${{CMAKE_Swift_MODULE_DIRECTORY}}
            )""".format(target=target.name, srcs=srcs, deps=deps))

        print(decl, file=output)

def write_exec_target(output):
    swiftbuild = textwrap.dedent("""\
        file(GLOB swiftbuild_SRC Sources/swift-build/*.swift)
        add_executable(swift-build
            ${swiftbuild_SRC}
        )
        target_link_libraries(swift-build
            Commands)
        """)
    print(swiftbuild, file=output)

def write_runtimes_target(output):
    swiftbuild = textwrap.dedent("""\
        file(GLOB PD_SRC Sources/PackageDescription4/*.swift)
        """)
    print(swiftbuild, file=output)

    for runtime in ["4", "4_2"]:
        gen = textwrap.dedent("""\
            add_library(PD{runtime}
                ${{PD_SRC}}
            )
            set_target_properties(PD{runtime} PROPERTIES
              Swift_MODULE_NAME PackageDescription
              Swift_MODULE_DIRECTORY ${{CMAKE_BINARY_DIR}}/runtimes/{runtime}
              OUTPUT_NAME PackageDescription
              LIBRARY_OUTPUT_DIRECTORY ${{CMAKE_BINARY_DIR}}/runtimes/{runtime}
            )
            target_compile_definitions(PD{runtime} PRIVATE PACKAGE_DESCRIPTION_{runtime})""".format(runtime=runtime))
        print(gen, file=output)

def write_main_cmake(targets):
    file = "/Users/ankit/workspace/swift.org/swiftpm/CMakeLists.txt"

    output = StringIO()

    add_preamble(output)
    add_library_targets(targets, output)
    write_exec_target(output)
    write_runtimes_target(output)

    write_file_if_changed(
            file, output.getvalue())

def main():
    parser = argparse.ArgumentParser()
    args = parser.parse_args()

    manifest_json = json.loads(dump_manifest())
    targets = make_targets(manifest_json)

    write_main_cmake(targets)

    bootstrap(args)

if __name__ == '__main__':
    main()
