/*
 This source file is part of the Swift.org open source project

 Copyright (c) 2014 - 2020 Apple Inc. and the Swift project authors
 Licensed under Apache License v2.0 with Runtime Library Exception

 See http://swift.org/LICENSE.txt for license information
 See http://swift.org/CONTRIBUTORS.txt for Swift project authors
*/

import Foundation

import TSCBasic
import TSCUtility

import SPMBuildCore
import Build
import PackageGraph
import PackageModel
import SourceControl
import Workspace
import ArgumentParser

/// A wrapper for swift-symbolgraph-extract tool.
public struct SymbolGraphExtract {
    let tool: AbsolutePath

    init(tool: AbsolutePath) {
        self.tool = tool
    }

    public func dumpSymbolGraph(
        buildPlan: BuildPlan,
        prettyPrint: Bool,
        skipSynthesisedMembers: Bool,
        minimumAccessLevel: AccessLevel,
        skipInheritedDocs: Bool,
        includeSPISymbols: Bool
    ) throws {
        let buildParameters = buildPlan.buildParameters
        let symbolGraphDirectory = buildPlan.buildParameters.symbolGraph
        try localFileSystem.createDirectory(symbolGraphDirectory, recursive: true)

        // Run the tool for each target in the root package.
        let targets = buildPlan.graph.rootPackages.flatMap{ $0.targets }.filter{ $0.type == .library || $0.type == .executable }
        for target in targets {
            var args = [String]()
            args += ["-module-name", target.c99name]
            args += try buildParameters.targetTripleArgs(for: target)

            args += buildPlan.createAPIToolCommonArgs(includeLibrarySearchPaths: true)
            args += ["-module-cache-path", buildParameters.moduleCache.pathString]

            args += ["-output-dir", symbolGraphDirectory.pathString]

            if prettyPrint { args.append("-pretty-print") }
            if skipSynthesisedMembers { args.append("-skip-synthesized-members") }
            if minimumAccessLevel != SwiftPackageTool.DumpSymbolGraph.defaultMinimumAccessLevel {
                args += ["-minimum-access-level", minimumAccessLevel.rawValue]
            }
            if skipInheritedDocs { args.append("-skip-inherited-docs") }
            if includeSPISymbols { args.append("-include-spi-symbols") }

            print("-- Emitting symbol graph for", target.name)
            try runTool(args)
        }
        print("Files written to", symbolGraphDirectory.pathString)
    }

    func runTool(_ args: [String]) throws {
        let arguments = [tool.pathString] + args
        let process = Process(
            arguments: arguments,
            outputRedirection: .none,
            verbose: verbosity != .concise
        )
        try process.launch()
        try process.waitUntilExit()
    }
}

/// Access control levels.
public enum AccessLevel: String, RawRepresentable, CustomStringConvertible, CaseIterable {
    // The cases reflect those found in `include/swift/AST/AttrKind.h` of the swift compiler (at commit 03f55d7bb4204ca54841218eb7cc175ae798e3bd)
    case `private`, `fileprivate`, `internal`, `public`, `open`

    public var description: String { rawValue }
}

extension AccessLevel: ExpressibleByArgument {}

extension BuildParameters {
    /// The directory containing artifacts generated by the symbolgraph-extract tool.
    var symbolGraph: AbsolutePath {
        dataPath.appending(component: "symbolgraph")
    }
}
