/*
 This source file is part of the Swift.org open source project

 Copyright (c) 2021 Apple Inc. and the Swift project authors
 Licensed under Apache License v2.0 with Runtime Library Exception

 See http://swift.org/LICENSE.txt for license information
 See http://swift.org/CONTRIBUTORS.txt for Swift project authors
*/

import Foundation

// Like package manifests, package extensions are Swift scripts that use API
// from a specialized PackageExtension library provided by SwiftPM. Extensions
// run in a sandbox and have read-only access to the package directory.
//
// The input to a package extension is passed by SwiftPM when it is invoked,
// and can be accessed through the `targetBuildContext` global. The extension
// generates commands to run during the build using the `commandConstructor`
// global, and can emit diagnostics using the `diagnosticsEmitter` global.
//
// The way in which SwiftPM communicates with the package extension is an im-
// plementation detail, but the way it currently works is that the extension
// is compiled (in a very similar way to the package manifest) and then run in
// a sandbox. Currently it is passed the JSON encoded input structure as the
// last command line argument; however, it this will likely change to instead
// read it from stdin, since that avoids any command line length limitation.
// Any generated commands and diagnostics are emitted on stdout after a zero
// byte; this allows regular output, such as print statements for debugging,
// to be emitted to SwiftPM verbatim. SwiftPM tries to interpret any stdout
// contents after the last zero byte as a JSON encoded output struct in UTF-8
// encoding; any failure to decode it is considered a protocol failure. The
// exit code of the compiled extension determines success or failure (though
// failure to decode the output is also considered a failure to run the ex-
// tension).


/// Provides information about the target being built, as well as contextual
/// information such as the paths of the directories to which commands should
/// be configured to write their outputs. This information should be used as
/// part of generating the commands to be run during the build.
public let targetBuildContext: TargetBuildContext = TargetBuildContextFactory()

/// Constructs commands to run during the build, including full command lines.
/// All paths should be based on the ones passed to the extension in the target
/// build context.
public let commandConstructor: CommandConstructor = CommandConstructor()

/// Emits errors, warnings, and remarks to be shown as a result of running the
/// extension. After emitting one or more errors, the extension should return a
/// non-zero exit code.
public let diagnosticsEmitter = DiagnosticsEmitter()


/// Provides information about the target being built, as well as contextual
/// information such as the paths of the directories to which commands should
/// be configured to write their outputs. This information should be used as
/// part of generating the commands to be run during the build.
public final class TargetBuildContext: Decodable {

    /// The name of the target being built.
    public let targetName: String
    
    /// The module name of the target. This is usually derived from the name,
    /// but is possibly be customizable in the package manifest in some future
    /// SwiftPM version).
    public let moduleName: String
    
    /// The path of the target directory.
    public let targetDir: Path
    
    /// That path of the package that contains the target.
    public let packageDir: Path
    
    /// Absolute paths of the source files in the target. This might include
    /// derived source files generated by other extensions).
    public let sourceFiles: [Path]

    /// Absolute paths of the resource files in the target.
    public let resourceFiles: [Path]

    /// Absolute paths of any other files (not sources or resources) in the target.
    public let otherFiles: [Path]

    /// Information about all targets on which the target for which the exten-
    /// sion is being invoked either directly or indirectly depends. This list
    /// is in topologically sorted order, with immediate dependencies appearing
    /// earlier and more distant dependencies later in the list. This is mainly
    /// intended for generating lists of search path arguments, etc.
    public let dependencies: [DependencyTargetInfo]
    
    /// Provides information about a target on which the target being built depends.
    public struct DependencyTargetInfo: Decodable {
        
        /// The name of the target.
        public let targetName: String
        
        /// The module name of the target. This is usually derived from the name,
        /// but is possibly be customizable in the package manifest in some future
        /// SwiftPM version).
        public let moduleName: String
        
        /// The path of the target directory.
        public let targetDir: Path
    }

    /// The path of an output directory into which files generated by the build
    /// commands that are set up by the package extension can be written.  The
    /// package extension itself may also write to this directory.
    public let outputDir: Path
    
    /// A directory into which the package extension or the tool it invokes can
    /// write any caches that speed up its operation or any other intermediate
    /// files that shouldn't be further processed.
    public let cacheDir: Path
    
    /// Looks up and returns the path of a named command line executable tool.
    /// The executable must be either in the toolchain or in the system search
    /// path for executables, or be provided by an executable target or binary
    /// target on which the package extension target depends. Returns nil, but
    /// does not throw an error, if the tool isn't found. Extensions that re-
    /// quire the tool should emit an error diagnostic if it cannot be found.
    public func lookupTool(named name: String) throws -> Path {
        // TODO: Rather than just appending the name, this should instead use
        // a mapping of tool names to paths (passed in from the context).
        return execsDir.appending(name)
    }
    
    /// A directory in which the built executables available to the extension
    /// will be located.
    /// TODO: This should instead be a mapping of tool names to paths (passed
    /// in from the context).
    private let execsDir: Path
}

/// Constructs commands to run during the build, including full command lines.
/// All paths should be based on the ones passed to the extension in the target
/// build context.
public final class CommandConstructor {
    
    fileprivate init() {}
    
    /// Creates a command to run during the build. The executable should be a
    /// path returned by `TargetBuildContext.lookupTool(named:)`, and all the
    /// paths in both the command line and the input and output lists should be
    /// based on the paths in the target build context structure.
    ///
    /// Note that input and output dependencies are ignored for prebuild and
    /// postbuild actions, since they always run before and after the build
    /// respectively.
    public func createCommand(displayName: String?, executable: Path, arguments: [String], workingDirectory: Path? = nil, environment: [String: String]? = nil, inputPaths: [Path] = [], outputPaths: [Path] = [], derivedSourcePaths: [Path] = []) {
        output.commands.append(Command(executable: executable, arguments: arguments, workingDirectory: workingDirectory, environment: environment, displayName: displayName, inputPaths: inputPaths, outputPaths: outputPaths, derivedSourcePaths: derivedSourcePaths))
    }
    
    func addGeneratedOutputFile(path: Path) {
        output.generatedFilePaths.append(path.string)
    }
    
    public func addPrebuildOutputDirectory(path: Path) {
        output.prebuildOutputDirectories.append(path.string)
    }
}

/// A constructed command.
fileprivate struct Command: Encodable {
    let executable: Path
    let arguments: [String]
    let workingDirectory: Path?
    let environment: [String: String]?
    let displayName: String?
    let inputPaths: [Path]
    let outputPaths: [Path]
    let derivedSourcePaths: [Path]
}

/// Emits errors, warnings, and remarks to be shown as a result of running the
/// extension. After emitting one or more errors, the extension should return a
/// non-zero exit code.
public final class DiagnosticsEmitter {
    
    fileprivate init() {}
    
    public func fatalError(_ message: String, file: Path? = nil, line: Int? = nil) {
        emit(error: message, file: file, line: line)
        exit(1)
    }
    
    public func emit(error message: String, file: Path? = nil, line: Int? = nil) {
        output.diagnostics.append(Diagnostic(severity: .error, message: message, file: file, line: line))
    }
    public func emit(warning message: String, file: Path? = nil, line: Int? = nil) {
        output.diagnostics.append(Diagnostic(severity: .warning, message: message, file: file, line: line))
    }
    public func emit(remark message: String, file: Path? = nil, line: Int? = nil) {
        output.diagnostics.append(Diagnostic(severity: .remark, message: message, file: file, line: line))
    }
}

// FIXME: This is preliminary.
public struct Diagnostic: Encodable {
    enum Severity: String, Encodable {
        case error, warning, remark
    }
    let severity: Severity
    let message: String
    let file: Path?
    let line: Int?
}

// FIXME: This is preliminary.
public struct Path: ExpressibleByStringLiteral, Encodable, Decodable {
    public var string: String
    
    init(_ string: String) {
        self.string = string
    }
    
    public func appending(_ components: [String]) -> Path {
        return Path(self.string.appending("/").appending(components.joined(separator: "/")))
    }
    
    public func appending(_ components: String...) -> Path {
        return appending(components)
    }
    
    public var filename: String {
        // Check for a special case of the root directory.
        if self.string == "/" {
            // Root directory, so the basename is a single path separator (the
            // root directory is special in this regard).
            return "/"
        }
        // Find the last path separator.
        guard let idx = string.lastIndex(of: "/") else {
            // No path separators, so the basename is the whole string.
            return string
        }
        // Otherwise, it's the string from (but not including) the last path
        // separator.
        return String(string.suffix(from: string.index(after: idx)))
    }
    
    public var basename: String {
        let filename = self.filename
        if let suff = self.suffix {
            return String(filename.dropLast(suff.count))
        }
        else {
            return filename
        }
    }
    
    public var suffix: String? {
        // Find the last path separator, if any.
        let sIdx = string.lastIndex(of: "/")
        
        // Find the start of the basename.
        let bIdx = (sIdx != nil) ? string.index(after: sIdx!) : string.startIndex
        
        // Find the last `.` (if any), starting from the second character of
        // the basename (a leading `.` does not make the whole path component
        // a suffix).
        let fIdx = string.index(bIdx, offsetBy: 1, limitedBy: string.endIndex) ?? string.startIndex
        if let idx = string[fIdx...].lastIndex(of: ".") {
            // Unless it's just a `.` at the end, we have found a suffix.
            if string.distance(from: idx, to: string.endIndex) > 1 {
                return String(string.suffix(from: idx))
            }
            else {
                return nil
            }
        }
        // If we get this far, there is no suffix.
        return nil
    }
    
    public func hasSuffix(_ suffix: String) -> Bool {
        return self.string.hasSuffix(suffix)
    }
    
    public init(stringLiteral value: String) {
        self.init(value)
    }

    public init(extendedGraphemeClusterLiteral value: String) {
        self.init(stringLiteral: value)
    }

    public init(unicodeScalarLiteral value: String) {
        self.init(stringLiteral: value)
    }

    public func encode(to encoder: Encoder) throws {
        var container = encoder.singleValueContainer()
        try container.encode(self.string)
    }

    public init(from decoder: Decoder) throws {
        let container = try decoder.singleValueContainer()
        let string = try container.decode(String.self)
        self.init(string)
    }
}



/// -=-=-=-=-=-=-=-=-=-=-  Implementation Details Below  -=-=-=-=-=-=-=-=-=-=-



/// Private initializer for the TargetBuildContext.  Expects the JSON form of
/// this structure to be in the last command line argument.  Also registers a
/// block to emit the output data at the end of the process.
fileprivate func TargetBuildContextFactory() -> TargetBuildContext {
    // Register a block to emit the JSON form of the output for SwiftPM to read.
    atexit {
        let encoder = JSONEncoder()
        let data = try! encoder.encode(output)
        fputc(0, stdout)
        fputs(String(data: data, encoding: .utf8)!, stdout)
        fflush(stdout)
    }
    // Look for the input JSON as the last argument of the invocation.
    guard let data = ProcessInfo.processInfo.arguments.last?.data(using: .utf8) else {
        output.diagnostics.append(Diagnostic(severity: .error, message:"Expected last argument to contain JSON input data in UTF-8 encoding, but didn't find it.", file: nil, line: nil))
        exit(1)
    }
    let buildContext: TargetBuildContext
    do {
        let decoder = JSONDecoder()
        buildContext = try decoder.decode(TargetBuildContext.self, from: data)
    }
    catch {
        output.diagnostics.append(Diagnostic(severity: .error, message: "\(error)", file: nil, line: nil))
        exit(1)
    }
    return buildContext
}


/// Private structure that contains the information to send back to SwiftPM.
fileprivate struct OutputStruct: Encodable {
    let version: Int
    var diagnostics: [Diagnostic] = []
    var commands: [Command] = []
    var generatedFilePaths: [String] = []
    var prebuildOutputDirectories: [String] = []
}
fileprivate var output = OutputStruct(version: 1)
